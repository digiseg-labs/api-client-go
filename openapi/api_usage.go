/*
Digiseg API

### Digiseg API documentation  # Introduction  This API let you harness the power of Digisegs powerful and tracking-free segmentation engine.  Audiences by Digiseg are available in 50+ countries, probablistically mapping neighborhood characteristics to the IP addresses observed on the internet - Household targeting & measurement for the post-cookie world.  ## Developer SDKs  In addition to using these APIs directly through any HTTP client, we provide a set of API client SDKs for popular programming languages:  <div class=\"api-clients\">   <a class=\"api-client-box\" href=\"https://github.com/digiseg-labs/api-client-python\">     <i class=\"api-client-sdk-logo devicon-python-plain\"></i>     <p>API client for Python</p>   </a>   <a class=\"api-client-box\" href=\"https://github.com/digiseg-labs/api-client-ts\">     <i class=\"api-client-sdk-logo devicon-typescript-plain\"></i>     <p>API client for TypeScript</p>   </a>   <a class=\"api-client-box\" href=\"https://github.com/digiseg-labs/api-client-go\">     <i class=\"api-client-sdk-logo devicon-go-original-wordmark\"></i>     <p>API client for Go</p>   </a> </div> <div class=\"api-clients-breaker\" /> 

API version: 1.0.0
Contact: support@digiseg.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// UsageAPIService UsageAPI service
type UsageAPIService service

type UsageAPIListAudienceDataDailyUsageRequest struct {
	ctx context.Context
	ApiService *UsageAPIService
	filterDateFrom *string
	filterDateTo *string
	filterAccountId *string
}

// Date to query from
func (r UsageAPIListAudienceDataDailyUsageRequest) FilterDateFrom(filterDateFrom string) UsageAPIListAudienceDataDailyUsageRequest {
	r.filterDateFrom = &filterDateFrom
	return r
}

// Date to query to
func (r UsageAPIListAudienceDataDailyUsageRequest) FilterDateTo(filterDateTo string) UsageAPIListAudienceDataDailyUsageRequest {
	r.filterDateTo = &filterDateTo
	return r
}

// Optional parameter used to query usage of specific account IDs (only available to super admins). 
func (r UsageAPIListAudienceDataDailyUsageRequest) FilterAccountId(filterAccountId string) UsageAPIListAudienceDataDailyUsageRequest {
	r.filterAccountId = &filterAccountId
	return r
}

func (r UsageAPIListAudienceDataDailyUsageRequest) Execute() (*ListAudienceDataDailyUsage200Response, *http.Response, error) {
	return r.ApiService.ListAudienceDataDailyUsageExecute(r)
}

/*
ListAudienceDataDailyUsage List daily usage of Audience Data

Provides usage stats on a daily basis. Results available for the last 2 months.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return UsageAPIListAudienceDataDailyUsageRequest
*/
func (a *UsageAPIService) ListAudienceDataDailyUsage(ctx context.Context) UsageAPIListAudienceDataDailyUsageRequest {
	return UsageAPIListAudienceDataDailyUsageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListAudienceDataDailyUsage200Response
func (a *UsageAPIService) ListAudienceDataDailyUsageExecute(r UsageAPIListAudienceDataDailyUsageRequest) (*ListAudienceDataDailyUsage200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListAudienceDataDailyUsage200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsageAPIService.ListAudienceDataDailyUsage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/usage/audience_data/daily"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterDateFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[date][from]", r.filterDateFrom, "form", "")
	}
	if r.filterDateTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[date][to]", r.filterDateTo, "form", "")
	}
	if r.filterAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[account_id]", r.filterAccountId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyHeaderAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-KEY"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyQueryParamAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UsageAPIListAudienceDataMonthlyUsageRequest struct {
	ctx context.Context
	ApiService *UsageAPIService
	filterYear *int32
	filterAccountId *string
}

// Year to filter by
func (r UsageAPIListAudienceDataMonthlyUsageRequest) FilterYear(filterYear int32) UsageAPIListAudienceDataMonthlyUsageRequest {
	r.filterYear = &filterYear
	return r
}

// Optional parameter used to query usage of specific account IDs (only available to super admins). 
func (r UsageAPIListAudienceDataMonthlyUsageRequest) FilterAccountId(filterAccountId string) UsageAPIListAudienceDataMonthlyUsageRequest {
	r.filterAccountId = &filterAccountId
	return r
}

func (r UsageAPIListAudienceDataMonthlyUsageRequest) Execute() (*ListAudienceDataMonthlyUsage200Response, *http.Response, error) {
	return r.ApiService.ListAudienceDataMonthlyUsageExecute(r)
}

/*
ListAudienceDataMonthlyUsage List monthly usage of Audience Data

Provides usage stats on a monthly basis.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return UsageAPIListAudienceDataMonthlyUsageRequest
*/
func (a *UsageAPIService) ListAudienceDataMonthlyUsage(ctx context.Context) UsageAPIListAudienceDataMonthlyUsageRequest {
	return UsageAPIListAudienceDataMonthlyUsageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListAudienceDataMonthlyUsage200Response
func (a *UsageAPIService) ListAudienceDataMonthlyUsageExecute(r UsageAPIListAudienceDataMonthlyUsageRequest) (*ListAudienceDataMonthlyUsage200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListAudienceDataMonthlyUsage200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsageAPIService.ListAudienceDataMonthlyUsage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/usage/audience_data/monthly"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterYear != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[year]", r.filterYear, "form", "")
	}
	if r.filterAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[account_id]", r.filterAccountId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyHeaderAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-KEY"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyQueryParamAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UsageAPIListAudienceDataRealtimeUsageRequest struct {
	ctx context.Context
	ApiService *UsageAPIService
	filterAccountId *string
}

// Optional parameter used to query usage of specific account IDs (only available to super admins). 
func (r UsageAPIListAudienceDataRealtimeUsageRequest) FilterAccountId(filterAccountId string) UsageAPIListAudienceDataRealtimeUsageRequest {
	r.filterAccountId = &filterAccountId
	return r
}

func (r UsageAPIListAudienceDataRealtimeUsageRequest) Execute() (*ListAudienceDataRealtimeUsage200Response, *http.Response, error) {
	return r.ApiService.ListAudienceDataRealtimeUsageExecute(r)
}

/*
ListAudienceDataRealtimeUsage List realtime usage of Audience Data

Provides usage stats on a near-realtime basis.
Results available for the last 24 hours, provided with as short delay as possible.
The results will be returned in usage objects, each representing 5 minutes of non-zero usage.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return UsageAPIListAudienceDataRealtimeUsageRequest
*/
func (a *UsageAPIService) ListAudienceDataRealtimeUsage(ctx context.Context) UsageAPIListAudienceDataRealtimeUsageRequest {
	return UsageAPIListAudienceDataRealtimeUsageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListAudienceDataRealtimeUsage200Response
func (a *UsageAPIService) ListAudienceDataRealtimeUsageExecute(r UsageAPIListAudienceDataRealtimeUsageRequest) (*ListAudienceDataRealtimeUsage200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListAudienceDataRealtimeUsage200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UsageAPIService.ListAudienceDataRealtimeUsage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/usage/audience_data/realtime"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[account_id]", r.filterAccountId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyHeaderAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-KEY"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyQueryParamAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("api_key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
